var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"@forward_methods\n@forward_interface\n@define_interface\n\nForwardMethods.iteration_interface\nForwardMethods.indexing_interface\nForwardMethods.lockable_interface\nForwardMethods.array_interface\nForwardMethods.dict_interface\nForwardMethods.getfields_interface\nForwardMethods.setfields_interface\nForwardMethods.properties_interface\nForwardMethods.equality_interface","category":"page"},{"location":"api/#ForwardMethods.@forward_methods","page":"API","title":"ForwardMethods.@forward_methods","text":"@forward_methods T [field=_field] [map=_map] methods...\n\nForwards the method definitions for x::T, depending on the value of _field. \n\n_field must be one of the following expressions\n\nk::Symbol or k::QuoteNode, or an expression of the form getfield(_, k), in which case methods will be forwarded to getfield(x, k)\nan expression of the form a.b.c. ..., in which case methods will be forwarded to getfield(getfield(getfield(x, :a), :b), :c) ...\nan expression of the form getproperty(_, k), in which case methods will be forwarded to getproperty(x, k)\nan expression of the form t[args...], in which case methods will be forwarded to x[args...]\nor an expression of the form f(_) for a single-argument function f, in which case methods will be forwarded to f(x)\n\nFor notational purposes below, call the forwarded value forwarded_value(x). \n\nEach method must be one of the following expressions \n\nan expression of the form f::Symbol or A.f, which will forward the single-argument function f(x) or A.f(x) to f(forwarded_value(x)) or A.f(forwarded_value(x)), respectively\na function signature of the form f(args...), or f(args...; kwargs...). In this form, there must be either exactly one expression of  the form x::T or _ (an underscore) in args. If this occurs at position i, say, this macro will forward this method to the definition\nf(args[1], args[2], ..., args[i-1], forwarded_value(x), args[i+1], ..., args[end]; kwargs...)\nWhen field maps to invoking getfield for field k, one can also write an argument expression of the form ::T or x::T. In this case, this macro definition will define\nf(args[1], ..., args[i-1], ::Type{T}, args[i+1], ..., args[end]; kwargs) = f(args[1], ..., args[i-1], fieldtype(T, k), args[i+1], ..., args[end]; kwargs)\nwhich can be useful for forwarding, for instance, trait-based methods to the corresponding container type. \n\nOptional Arguments\n\nThe optional map=_map parameter allows you to apply an expression transformation to the resulting forwarded expression. _map must be an expression containing at least one underscore _ placeholder and optionally _obj placeholders. _ and _obj will be replaced with the transformed function and initial object argument, respectively. \n\nFor example, if we have \n\n    struct LockableDict{K,V}\n        d::Dict{K,V}\n        lock::ReentrantLock\n    end\n    @forward LockableDict{K,V} field=lock Base.lock Base.unlock\n    @forward LockableDict{K,V} field=d map=(begin lock(_obj); try _ finally unlock(_obj) end end) Base.getindex(_, k) \n\nThen the expressions generated in the second statement are (roughly) of the form \n\n    function Base.getindex(l::LockableDict{K,V}, k)\n        lock(l)\n        try \n            Base.getindex(getfield(l, :d))\n        finally\n            unlock(l)\n        end\n    end\n\nNotes\n\nParametric expressions are supported for T, as well as for the function signature form of method\n\nExamples\n\njulia> struct B{T} \n         v::Vector{T}\n       end\n\njulia> @forward_methods B{T} field=v Base.firstindex Base.lastindex Base.getindex(_, k::Int) Base.setindex!(x::B, v, k) (Base.eachindex(x::B{T}) where {T})\n\njulia> b = B([1,2,3])\nB{Int64}([1, 2, 3])\n\njulia> for i in eachindex(b)\n         b[i] = b[i]^2\n       end\njulia> b[end]\n9\n\njulia> struct C\n         d::Dict{String,Int}\n       end\njulia> @forward_methods C field=d Base.keytype(::Type{C}) Base.valtype(::Type{C})\n\njulia> keytype(C)\nString \n\njulia> valtype(C)\nInt\n\n\n\n\n\n","category":"macro"},{"location":"api/#ForwardMethods.@forward_interface","page":"API","title":"ForwardMethods.@forward_interface","text":"@forward_interface T [field=_field] [interface=name] [map=_map] [key=value...]\n\nForwards the methods defined for interface to objects of type T\n\nArguments\n\nname must be one of (:iteration, :indexing, :array, :dict, :lockable, :getfields, :setfields), with name value f corresponding to the interface definition function $f_interface (e.g., array => array_interface).\n\nIf name is either getfields or setfields, then the field keyword argument is ignored \n\nOtherwise, _field must be one of the following expressions\n\nk::Symbol or k::QuoteNode, or an expression of the form getfield(_, k), in which case methods will be forwarded to getfield(x, k)\nan expression of the form getproperty(_, k), in which case methods will be forwarded to getproperty(x, k)\nan expression of the form t[args...], in which case methods will be forwarded to x[args...]\nor an expression of the form f(_) for a single-argument function f, in which case methods will be forwarded to f(x)\n\nAdditional Arguments\n\nThe key=value pairs will be forwarded to the corresponding interface definition method. In particular, specifying omit=func1 or omit=[func1,func2, ..., funcn] will omit func1, ..., funcn from being forwarded by this macro.\n\nSee also @forward_methods\n\n\n\n\n\n","category":"macro"},{"location":"api/#ForwardMethods.@define_interface","page":"API","title":"ForwardMethods.@define_interface","text":"@define_interface T [interface=name] [kwargs...]\n\nDefines the interface for objects of type T\n\nArguments\n\nname must be one of (:properties, :equality, :setfields, :getfields), with name value f corresponding to the interface definition function $f_interface (e.g., array => array_interface).\n\nThe key=value pairs will be forwarded to the corresponding interface definition method. In particular, specifying omit=func1 or omit=[func1,func2, ..., funcn] will omit func1, ..., funcn from being forwarded by this macro.\n\nRefer to the documentation of each name_interface for the specific keyword arguments required, if any. \n\n\n\n\n\n","category":"macro"},{"location":"api/#ForwardMethods.iteration_interface","page":"API","title":"ForwardMethods.iteration_interface","text":"ForwardMethods.iteration_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.iterate(x::T)\nBase.iterate(x::T, state)\nBase.IteratorSize(::Type{T})\nBase.IteratorEltype(::Type{T})\nBase.eltype(::Type{T})\nBase.length(x::T)\nBase.size(x::T)\nBase.isdone(x::T)\nBase.isdone(x::T, state)\n\nAny function names specified in omit::AbstractVector{Symbol} (aside from :iterate) will not be defined\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.indexing_interface","page":"API","title":"ForwardMethods.indexing_interface","text":"ForwardMethods.indexing_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.getindex(x::T, index)\nBase.setindex!(x::T, value, index)\nBase.firstindex(x::T)\nBase.lastindex(x::T)\n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.lockable_interface","page":"API","title":"ForwardMethods.lockable_interface","text":"ForwardMethods.lockable_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.lock(x::T)\nBase.lock(f, x::T)\nBase.unlock(x::T)\nBase.trylock(x::T)\nBase.islocked(x::T)\n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.array_interface","page":"API","title":"ForwardMethods.array_interface","text":"ForwardMethods.array(T; index_style_linear::Bool, omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.size(x::T)\nBase.iterate(x::T)\nBase.iterate(x::T, state)\nBase.length(x::T)\nBase.IndexStyle(::Type{T})\nBase.getindex(x::T, index)\nBase.setindex!(x::T, value, index)\n\nThe signatures for Base.getindex + Base.setindex! will be set  according to the value of index_style_linear \n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.dict_interface","page":"API","title":"ForwardMethods.dict_interface","text":"ForwardMethods.dict_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.keys(x::T)\nBase.values(x::T)\nBase.pairs(x::T)\nBase.length(x::T)\nBase.isempty(x::T)\nBase.empty!(x::T)\nBase.iterate(x::T)\nBase.iterate(x::T, state)\nBase.pop!(x::T, key)\nBase.delete!(x::T, key)\nBase.haskey(x::T, key)\nBase.getindex(x::T, key)\nBase.setindex!(x::T, value, key)\nBase.get(x::T, key, default_value)\nBase.get!(default::Callable, x::T, key)\nBase.in(value, x::T)\n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.getfields_interface","page":"API","title":"ForwardMethods.getfields_interface","text":"getfields_interface(T; omit=Symbol[])\n\nGiven x::T, forwards the method $field(x::T) to getfield(x, $field), for each field in fieldnames(T)\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.setfields_interface","page":"API","title":"ForwardMethods.setfields_interface","text":"setfields_interface(T; omit=Symbol[])\n\nGiven x::T, forwards the method $field!(x::T, value) to setfield!(x, $field, value), for each field in fieldnames(T)\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.properties_interface","page":"API","title":"ForwardMethods.properties_interface","text":"properties_interface(T; delegated_fields, [is_mutable=false])\n\nGiven x::T for a struct type T, defines Base.propertynames(x::T) in terms of the fieldnames(T) as well as the fieldnames of getfield(x, k) for each k in delegated_fields.\n\nAlso forwards Base.getproperty(x::T, name::Symbol) to  getfield(getfield(x, k), name) for the first k such that hasfield(getfield(x, k), name)\n\nIf T is a mutable type, also defines Base.setproperty!(x::T, name::Symbol, value) in a similar fashion to the Base.getproperty above. This feature requires at least Julia 1.7. On older Julia versions, pass in the is_mutable = true keyword argument.\n\nArguments\n\ndelegated_fields can be either a Symbol, or a vect or tuple Expr of Symbols, corresponding to fieldnames of T\n\n\n\n\n\n","category":"function"},{"location":"api/#ForwardMethods.equality_interface","page":"API","title":"ForwardMethods.equality_interface","text":"equality_interface(T; [omit=Symbol[], equality_op=:(==), compare_fields=:fieldnames])\n\nDefines the equality_op operator for two objects of type T in the natural way, i.e., \n\n    Base.:(==)(x::T, y::T) = all( getfield(x,k) == getfield(y,k) for k in fieldnames(T))\n\nArguments\n\nIf equality_op == isequal, defines Base.isequal instead.\n\nIf compare_fields == propertynames, the above definition uses getproperty and propertynames(x) instead of getfield and fieldnames(T), respectively.\n\nAny values provided in omit are excluded from the generator expression above.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ForwardMethods","category":"page"},{"location":"#ForwardMethods","page":"Home","title":"ForwardMethods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ForwardMethods package provides macros that remove much of the boilerplate of method-forwarding i.e., defining a series of method instances for an object by forwarding to the same method applied to a particular field. ","category":"page"}]
}
