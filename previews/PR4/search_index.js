var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [ForwardMethods]\nOrder   = [:macro, :function] \nPrivate = false","category":"page"},{"location":"api/#ForwardMethods.@forward_interface-Tuple{Any, Vararg{Any}}","page":"API","title":"ForwardMethods.@forward_interface","text":"@forward_interface T [field=_field] [interface=_interface] [map=_map] [kwargs...]\n\nForwards the methods defined for interface to objects of type T\n\nArguments\n\n_interface must be one of (:iteration, :indexing, :array, :dict, :lockable, :getfields, :setfields), with _interface value f corresponding to the interface definition function $f_interface (e.g., array => array_interface).\n\nIf _interface is either getfields or setfields, then the field keyword argument is ignored \n\nOtherwise, _field must be one of the following expressions\n\nk::Symbol or k::QuoteNode, or an expression of the form getfield(_, k), in which case methods will be forwarded to getfield(x, k)\nan expression of the form getproperty(_, k), in which case methods will be forwarded to getproperty(x, k)\nan expression of the form t[args...], in which case methods will be forwarded to x[args...]\nor an expression of the form f(_) for a single-argument function f, in which case methods will be forwarded to f(x)\n\nAdditional Arguments\n\nThe key=value pairs will be forwarded to the corresponding interface definition method. In particular, specifying omit=func1 or omit=[func1,func2, ..., funcn] will omit func1, ..., funcn from being forwarded by this macro.\n\nSee also @forward_methods\n\n\n\n\n\n","category":"macro"},{"location":"api/#ForwardMethods.@forward_methods-Tuple{Any, Any, Vararg{Any}}","page":"API","title":"ForwardMethods.@forward_methods","text":"@forward_methods T [field=_field] [map=_map] methods...\n\nForwards the method definitions for x::T, depending on the value of _field. \n\n_field must be one of the following expressions\n\nk::Symbol or k::QuoteNode, or an expression of the form getfield(_, k), in which case methods will be forwarded to getfield(x, k)\nan expression of the form a.b.c. ..., in which case methods will be forwarded to getfield(getfield(getfield(x, :a), :b), :c) ...\nan expression of the form getproperty(_, k), in which case methods will be forwarded to getproperty(x, k)\nan expression of the form t[args...], in which case methods will be forwarded to x[args...]\nor an expression of the form f(_) for a single-argument function f, in which case methods will be forwarded to f(x)\n\nFor notational purposes below, call the forwarded value forwarded_value(x). \n\nEach method must be one of the following expressions \n\nan expression of the form f::Symbol or A.f, which will forward the single-argument function f(x) or A.f(x) to f(forwarded_value(x)) or A.f(forwarded_value(x)), respectively\na function signature of the form f(args...), or f(args...; kwargs...). In this form, there must be either exactly one expression of  the form x::T or _ (an underscore) in args. If this occurs at position i, say, this macro will forward this method to the definition\nf(args[1], args[2], ..., args[i-1], forwarded_value(x), args[i+1], ..., args[end]; kwargs...)\nWhen field maps to invoking getfield for field k, one can also write an argument expression of the form ::T or x::T. In this case, this macro definition will define\nf(args[1], ..., args[i-1], ::Type{T}, args[i+1], ..., args[end]; kwargs) = f(args[1], ..., args[i-1], fieldtype(T, k), args[i+1], ..., args[end]; kwargs)\nwhich can be useful for forwarding, for instance, trait-based methods to the corresponding container type. \n\nOptional Arguments\n\nThe optional map=_map parameter allows you to apply an expression transformation to the resulting forwarded expression. _map must be an expression containing at least one underscore _ placeholder and optionally _obj placeholders. _ and _obj will be replaced with the transformed function and initial object argument, respectively. \n\nFor example, if we have \n\n    struct LockableDict{K,V}\n        d::Dict{K,V}\n        lock::ReentrantLock\n    end\n    @forward LockableDict{K,V} field=lock Base.lock Base.unlock\n    @forward LockableDict{K,V} field=d map=(begin lock(_obj); try _ finally unlock(_obj) end end) Base.getindex(_, k) \n\nThen the expressions generated in the second statement are (roughly) of the form \n\n    function Base.getindex(l::LockableDict{K,V}, k)\n        lock(l)\n        try \n            Base.getindex(getfield(l, :d))\n        finally\n            unlock(l)\n        end\n    end\n\nNotes\n\nParametric expressions are supported for T, as well as for the function signature form of method\n\nExamples\n\njulia> struct B{T} \n         v::Vector{T}\n       end\n\njulia> @forward_methods B{T} field=v Base.firstindex Base.lastindex Base.getindex(_, k::Int) Base.setindex!(x::B, v, k) (Base.eachindex(x::B{T}) where {T})\n\njulia> b = B([1,2,3])\nB{Int64}([1, 2, 3])\n\njulia> for i in eachindex(b)\n         b[i] = b[i]^2\n       end\njulia> b[end]\n9\n\njulia> struct C\n         d::Dict{String,Int}\n       end\njulia> @forward_methods C field=d Base.keytype(::Type{C}) Base.valtype(::Type{C})\n\njulia> keytype(C)\nString \n\njulia> valtype(C)\nInt\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"ForwardMethods.iteration_interface(T; omit)\nForwardMethods.indexing_interface(T; omit)\nForwardMethods.lockable_interface(T; omit)\nForwardMethods.array_interface(T; omit)\nForwardMethods.dict_interface(T; omit)","category":"page"},{"location":"api/#ForwardMethods.iteration_interface-Tuple{Any}","page":"API","title":"ForwardMethods.iteration_interface","text":"ForwardMethods.iteration_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.iterate(x::T)\nBase.iterate(x::T, state)\nBase.IteratorSize(::Type{T})\nBase.IteratorEltype(::Type{T})\nBase.eltype(::Type{T})\nBase.length(x::T)\nBase.size(x::T)\nBase.isdone(x::T)\nBase.isdone(x::T, state)\n\nAny function names specified in omit::AbstractVector{Symbol} (aside from :iterate) will not be defined\n\n\n\n\n\n","category":"method"},{"location":"api/#ForwardMethods.indexing_interface-Tuple{Any}","page":"API","title":"ForwardMethods.indexing_interface","text":"ForwardMethods.indexing_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.getindex(x::T, index)\nBase.setindex!(x::T, value, index)\nBase.firstindex(x::T)\nBase.lastindex(x::T)\n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"method"},{"location":"api/#ForwardMethods.lockable_interface-Tuple{Any}","page":"API","title":"ForwardMethods.lockable_interface","text":"ForwardMethods.lockable_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.lock(x::T)\nBase.lock(f, x::T)\nBase.unlock(x::T)\nBase.trylock(x::T)\nBase.islocked(x::T)\n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"method"},{"location":"api/#ForwardMethods.array_interface-Tuple{Any}","page":"API","title":"ForwardMethods.array_interface","text":"ForwardMethods.array(T; index_style_linear::Bool, omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.size(x::T)\nBase.iterate(x::T)\nBase.iterate(x::T, state)\nBase.length(x::T)\nBase.IndexStyle(::Type{T})\nBase.getindex(x::T, index)\nBase.setindex!(x::T, value, index)\n\nThe signatures for Base.getindex + Base.setindex! will be set  according to the value of index_style_linear \n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"method"},{"location":"api/#ForwardMethods.dict_interface-Tuple{Any}","page":"API","title":"ForwardMethods.dict_interface","text":"ForwardMethods.dict_interface(T; omit=Symbol[])\n\nForwards the following methods for x::T:\n\nBase.keys(x::T)\nBase.values(x::T)\nBase.pairs(x::T)\nBase.length(x::T)\nBase.isempty(x::T)\nBase.empty!(x::T)\nBase.iterate(x::T)\nBase.iterate(x::T, state)\nBase.pop!(x::T, key)\nBase.delete!(x::T, key)\nBase.haskey(x::T, key)\nBase.getindex(x::T, key)\nBase.setindex!(x::T, value, key)\nBase.get(x::T, key, default_value)\nBase.get!(default::Callable, x::T, key)\nBase.in(value, x::T)\n\nAny function names specified in omit::AbstractVector{Symbol} will not be defined\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ForwardMethods","category":"page"},{"location":"#ForwardMethods","page":"Home","title":"ForwardMethods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The ForwardMethods package provides macros that remove much of the boilerplate of method-forwarding i.e., defining a series of method instances for an object by forwarding to the same method applied to a particular field. ","category":"page"}]
}
